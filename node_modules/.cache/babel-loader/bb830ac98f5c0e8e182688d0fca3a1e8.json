{"ast":null,"code":"const {\n  wikibaseTimeToISOString,\n  wikibaseTimeToEpochTime,\n  wikibaseTimeToSimpleDay\n} = require('./helpers');\n\nconst simple = datavalue => datavalue.value;\n\nconst monolingualtext = (datavalue, options) => {\n  return options.keepRichValues ? datavalue.value : datavalue.value.text;\n};\n\nconst entity = (datavalue, options) => prefixedId(datavalue, options.entityPrefix);\n\nconst entityLetter = {\n  item: 'Q',\n  lexeme: 'L',\n  property: 'P'\n};\n\nconst prefixedId = (datavalue, prefix) => {\n  const {\n    value\n  } = datavalue;\n  const id = value.id || entityLetter[value['entity-type']] + value['numeric-id'];\n  return typeof prefix === 'string' ? `${prefix}:${id}` : id;\n};\n\nconst quantity = (datavalue, options) => {\n  const {\n    value\n  } = datavalue;\n  const amount = parseFloat(value.amount);\n\n  if (options.keepRichValues) {\n    const richValue = {\n      amount: parseFloat(value.amount),\n      // ex: http://www.wikidata.org/entity/\n      unit: value.unit.replace(/^https?:\\/\\/.*\\/entity\\//, '')\n    };\n    if (value.upperBound != null) richValue.upperBound = parseFloat(value.upperBound);\n    if (value.lowerBound != null) richValue.lowerBound = parseFloat(value.lowerBound);\n    return richValue;\n  } else {\n    return amount;\n  }\n};\n\nconst coordinate = (datavalue, options) => {\n  if (options.keepRichValues) {\n    return datavalue.value;\n  } else {\n    return [datavalue.value.latitude, datavalue.value.longitude];\n  }\n};\n\nconst time = (datavalue, options) => {\n  let timeValue;\n\n  if (typeof options.timeConverter === 'function') {\n    timeValue = options.timeConverter(datavalue.value);\n  } else {\n    timeValue = getTimeConverter(options.timeConverter)(datavalue.value);\n  }\n\n  if (options.keepRichValues) {\n    const {\n      timezone,\n      before,\n      after,\n      precision,\n      calendarmodel\n    } = datavalue.value;\n    return {\n      time: timeValue,\n      timezone,\n      before,\n      after,\n      precision,\n      calendarmodel\n    };\n  } else {\n    return timeValue;\n  }\n};\n\nconst getTimeConverter = function () {\n  let key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'iso';\n  const converter = timeConverters[key];\n  if (!converter) throw new Error(`invalid converter key: ${JSON.stringify(key).substring(0, 100)}`);\n  return converter;\n}; // Each time converter should be able to accept 2 keys of arguments:\n// - either datavalue.value objects (prefered as it gives access to the precision)\n// - or the time string (datavalue.value.time)\n\n\nconst timeConverters = {\n  iso: wikibaseTimeToISOString,\n  epoch: wikibaseTimeToEpochTime,\n  'simple-day': wikibaseTimeToSimpleDay,\n  none: wikibaseTime => wikibaseTime.time || wikibaseTime\n};\nconst parsers = {\n  commonsMedia: simple,\n  'external-id': simple,\n  'geo-shape': simple,\n  'globe-coordinate': coordinate,\n  math: simple,\n  monolingualtext,\n  'musical-notation': simple,\n  quantity,\n  string: simple,\n  'tabular-data': simple,\n  time,\n  url: simple,\n  'wikibase-entityid': entity,\n  'wikibase-form': entity,\n  'wikibase-item': entity,\n  'wikibase-lexeme': entity,\n  'wikibase-property': entity,\n  'wikibase-sense': entity\n};\nmodule.exports = {\n  parsers,\n  parse: (datatype, datavalue, options, claimId) => {\n    // Known case of missing datatype: form.claims, sense.claims\n    datatype = datatype || datavalue.type; // Known case requiring this: legacy \"muscial notation\" datatype\n\n    datatype = datatype.replace(' ', '-');\n\n    try {\n      return parsers[datatype](datavalue, options);\n    } catch (err) {\n      if (err.message === 'parsers[datatype] is not a function') {\n        err.message = `${datatype} claim parser isn't implemented\n        Claim id: ${claimId}\n        Please report to https://github.com/maxlath/wikibase-sdk/issues`;\n      }\n\n      throw err;\n    }\n  }\n};","map":{"version":3,"names":["wikibaseTimeToISOString","wikibaseTimeToEpochTime","wikibaseTimeToSimpleDay","require","simple","datavalue","value","monolingualtext","options","keepRichValues","text","entity","prefixedId","entityPrefix","entityLetter","item","lexeme","property","prefix","id","quantity","amount","parseFloat","richValue","unit","replace","upperBound","lowerBound","coordinate","latitude","longitude","time","timeValue","timeConverter","getTimeConverter","timezone","before","after","precision","calendarmodel","key","converter","timeConverters","Error","JSON","stringify","substring","iso","epoch","none","wikibaseTime","parsers","commonsMedia","math","string","url","module","exports","parse","datatype","claimId","type","err","message"],"sources":["/Users/aarongmduran/Desktop/tornados/tornados/node_modules/wikibase-sdk/lib/helpers/parse_claim.js"],"sourcesContent":["const { wikibaseTimeToISOString, wikibaseTimeToEpochTime, wikibaseTimeToSimpleDay } = require('./helpers')\n\nconst simple = datavalue => datavalue.value\n\nconst monolingualtext = (datavalue, options) => {\n  return options.keepRichValues ? datavalue.value : datavalue.value.text\n}\n\nconst entity = (datavalue, options) => prefixedId(datavalue, options.entityPrefix)\n\nconst entityLetter = {\n  item: 'Q',\n  lexeme: 'L',\n  property: 'P'\n}\n\nconst prefixedId = (datavalue, prefix) => {\n  const { value } = datavalue\n  const id = value.id || entityLetter[value['entity-type']] + value['numeric-id']\n  return typeof prefix === 'string' ? `${prefix}:${id}` : id\n}\n\nconst quantity = (datavalue, options) => {\n  const { value } = datavalue\n  const amount = parseFloat(value.amount)\n  if (options.keepRichValues) {\n    const richValue = {\n      amount: parseFloat(value.amount),\n      // ex: http://www.wikidata.org/entity/\n      unit: value.unit.replace(/^https?:\\/\\/.*\\/entity\\//, '')\n    }\n    if (value.upperBound != null) richValue.upperBound = parseFloat(value.upperBound)\n    if (value.lowerBound != null) richValue.lowerBound = parseFloat(value.lowerBound)\n    return richValue\n  } else {\n    return amount\n  }\n}\n\nconst coordinate = (datavalue, options) => {\n  if (options.keepRichValues) {\n    return datavalue.value\n  } else {\n    return [ datavalue.value.latitude, datavalue.value.longitude ]\n  }\n}\n\nconst time = (datavalue, options) => {\n  let timeValue\n  if (typeof options.timeConverter === 'function') {\n    timeValue = options.timeConverter(datavalue.value)\n  } else {\n    timeValue = getTimeConverter(options.timeConverter)(datavalue.value)\n  }\n  if (options.keepRichValues) {\n    const { timezone, before, after, precision, calendarmodel } = datavalue.value\n    return { time: timeValue, timezone, before, after, precision, calendarmodel }\n  } else {\n    return timeValue\n  }\n}\n\nconst getTimeConverter = (key = 'iso') => {\n  const converter = timeConverters[key]\n  if (!converter) throw new Error(`invalid converter key: ${JSON.stringify(key).substring(0, 100)}`)\n  return converter\n}\n\n// Each time converter should be able to accept 2 keys of arguments:\n// - either datavalue.value objects (prefered as it gives access to the precision)\n// - or the time string (datavalue.value.time)\nconst timeConverters = {\n  iso: wikibaseTimeToISOString,\n  epoch: wikibaseTimeToEpochTime,\n  'simple-day': wikibaseTimeToSimpleDay,\n  none: wikibaseTime => wikibaseTime.time || wikibaseTime\n}\n\nconst parsers = {\n  commonsMedia: simple,\n  'external-id': simple,\n  'geo-shape': simple,\n  'globe-coordinate': coordinate,\n  math: simple,\n  monolingualtext,\n  'musical-notation': simple,\n  quantity,\n  string: simple,\n  'tabular-data': simple,\n  time,\n  url: simple,\n  'wikibase-entityid': entity,\n  'wikibase-form': entity,\n  'wikibase-item': entity,\n  'wikibase-lexeme': entity,\n  'wikibase-property': entity,\n  'wikibase-sense': entity\n}\n\nmodule.exports = {\n  parsers,\n  parse: (datatype, datavalue, options, claimId) => {\n    // Known case of missing datatype: form.claims, sense.claims\n    datatype = datatype || datavalue.type\n    // Known case requiring this: legacy \"muscial notation\" datatype\n    datatype = datatype.replace(' ', '-')\n\n    try {\n      return parsers[datatype](datavalue, options)\n    } catch (err) {\n      if (err.message === 'parsers[datatype] is not a function') {\n        err.message = `${datatype} claim parser isn't implemented\n        Claim id: ${claimId}\n        Please report to https://github.com/maxlath/wikibase-sdk/issues`\n      }\n      throw err\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}