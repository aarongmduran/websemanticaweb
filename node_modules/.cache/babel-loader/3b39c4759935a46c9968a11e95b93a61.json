{"ast":null,"code":"const {\n  parse: parseClaim\n} = require('./parse_claim');\n\nconst {\n  uniq\n} = require('../utils/utils');\n\nconst {\n  truthyPropertyClaims,\n  nonDeprecatedPropertyClaims\n} = require('./rank'); // Expects an entity 'claims' object\n// Ex: entity.claims\n\n\nconst simplifyClaims = function (claims) {\n  for (var _len = arguments.length, options = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    options[_key - 1] = arguments[_key];\n  }\n\n  const {\n    propertyPrefix\n  } = parseOptions(options);\n  const simpleClaims = {};\n\n  for (let id in claims) {\n    const propClaims = claims[id];\n\n    if (propertyPrefix) {\n      id = propertyPrefix + ':' + id;\n    }\n\n    simpleClaims[id] = simplifyPropertyClaims(propClaims, ...options);\n  }\n\n  return simpleClaims;\n}; // Expects the 'claims' array of a particular property\n// Ex: entity.claims.P369\n\n\nconst simplifyPropertyClaims = function (propClaims) {\n  for (var _len2 = arguments.length, options = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    options[_key2 - 1] = arguments[_key2];\n  }\n\n  // Avoid to throw on empty inputs to allow to simplify claims array\n  // without having to know if the entity as claims for this property\n  // Ex: simplifyPropertyClaims(entity.claims.P124211616)\n  if (propClaims == null || propClaims.length === 0) return [];\n  const {\n    keepNonTruthy,\n    keepNonDeprecated,\n    areSubSnaks\n  } = parseOptions(options);\n\n  if (keepNonDeprecated) {\n    propClaims = nonDeprecatedPropertyClaims(propClaims);\n  } else if (!(keepNonTruthy || areSubSnaks)) {\n    propClaims = truthyPropertyClaims(propClaims);\n  }\n\n  propClaims = propClaims.map(claim => simplifyClaim(claim, ...options)) // Filter-out novalue and somevalue claims,\n  // unless a novalueValue or a somevalueValue is passed in options\n  .filter(defined); // Deduplicate values unless we return a rich value object\n\n  if (propClaims[0] && typeof propClaims[0] !== 'object') {\n    return uniq(propClaims);\n  } else {\n    return propClaims;\n  }\n}; // Considers null as defined\n\n\nconst defined = obj => obj !== undefined; // Expects a single claim object\n// Ex: entity.claims.P369[0]\n\n\nconst simplifyClaim = function (claim) {\n  for (var _len3 = arguments.length, options = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    options[_key3 - 1] = arguments[_key3];\n  }\n\n  options = parseOptions(options);\n  const {\n    keepQualifiers,\n    keepReferences,\n    keepIds,\n    keepHashes,\n    keepTypes,\n    keepSnaktypes,\n    keepRanks\n  } = parseKeepOptions(options); // tries to replace wikidata deep claim object by a simple value\n  // e.g. a string, an entity Qid or an epoch time number\n\n  const {\n    mainsnak,\n    rank\n  } = claim;\n  let value, datatype, datavalue, snaktype, isQualifierSnak, isReferenceSnak;\n\n  if (mainsnak) {\n    datatype = mainsnak.datatype;\n    datavalue = mainsnak.datavalue;\n    snaktype = mainsnak.snaktype;\n  } else {\n    // Qualifiers have no mainsnak, and define datatype, datavalue on claim\n    datavalue = claim.datavalue;\n    datatype = claim.datatype;\n    snaktype = claim.snaktype; // Duck typing the sub-snak type\n\n    if (claim.hash) isQualifierSnak = true;else isReferenceSnak = true;\n  }\n\n  if (datavalue) {\n    value = parseClaim(datatype, datavalue, options, claim.id);\n  } else {\n    if (snaktype === 'somevalue') value = options.somevalueValue;else if (snaktype === 'novalue') value = options.novalueValue;else throw new Error('no datavalue or special snaktype found');\n  } // Qualifiers should not attempt to keep sub-qualifiers or references\n\n\n  if (isQualifierSnak) {\n    if (!(keepHashes || keepTypes || keepSnaktypes)) return value;\n    const valueObj = {\n      value\n    };\n    if (keepHashes) valueObj.hash = claim.hash;\n    if (keepTypes) valueObj.type = datatype;\n    if (keepSnaktypes) valueObj.snaktype = snaktype;\n    return valueObj;\n  }\n\n  if (isReferenceSnak) {\n    if (!keepTypes) return value;\n    return {\n      type: datatype,\n      value\n    };\n  } // No need to test keepHashes as it has no effect if neither\n  // keepQualifiers or keepReferences is true\n\n\n  if (!(keepQualifiers || keepReferences || keepIds || keepTypes || keepSnaktypes || keepRanks)) {\n    return value;\n  } // When keeping qualifiers or references, the value becomes an object\n  // instead of a direct value\n\n\n  const valueObj = {\n    value\n  };\n  if (keepTypes) valueObj.type = datatype;\n  if (keepSnaktypes) valueObj.snaktype = snaktype;\n  if (keepRanks) valueObj.rank = rank;\n  const subSnaksOptions = getSubSnakOptions(options);\n  subSnaksOptions.keepHashes = keepHashes;\n\n  if (keepQualifiers) {\n    valueObj.qualifiers = simplifyQualifiers(claim.qualifiers, subSnaksOptions);\n  }\n\n  if (keepReferences) {\n    claim.references = claim.references || [];\n    valueObj.references = simplifyReferences(claim.references, subSnaksOptions);\n  }\n\n  if (keepIds) valueObj.id = claim.id;\n  return valueObj;\n};\n\nconst parseOptions = options => {\n  if (options == null) return {};\n  if (options[0] && typeof options[0] === 'object') return options[0]; // Legacy interface\n\n  const [entityPrefix, propertyPrefix, keepQualifiers] = options;\n  return {\n    entityPrefix,\n    propertyPrefix,\n    keepQualifiers\n  };\n};\n\nconst simplifyQualifiers = (qualifiers, options) => {\n  return simplifyClaims(qualifiers, getSubSnakOptions(options));\n};\n\nconst simplifyPropertyQualifiers = (propertyQualifiers, options) => {\n  return simplifyPropertyClaims(propertyQualifiers, getSubSnakOptions(options));\n};\n\nconst simplifyReferences = (references, options) => {\n  return references.map(refRecord => {\n    return simplifyReferenceRecord(refRecord, options);\n  });\n};\n\nconst simplifyReferenceRecord = (refRecord, options) => {\n  const subSnaksOptions = getSubSnakOptions(options);\n  const snaks = simplifyClaims(refRecord.snaks, subSnaksOptions);\n  if (subSnaksOptions.keepHashes) return {\n    snaks,\n    hash: refRecord.hash\n  };else return snaks;\n};\n\nconst getSubSnakOptions = function () {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  if (options.areSubSnaks) return options; // Using a new object so that the original options object isn't modified\n  else return Object.assign({}, options, {\n    areSubSnaks: true\n  });\n};\n\nconst keepOptions = ['keepQualifiers', 'keepReferences', 'keepIds', 'keepHashes', 'keepTypes', 'keepSnaktypes', 'keepRanks', 'keepRichValues'];\n\nconst parseKeepOptions = options => {\n  if (options.keepAll) {\n    keepOptions.forEach(optionName => {\n      if (options[optionName] == null) options[optionName] = true;\n    });\n  }\n\n  return options;\n};\n\nmodule.exports = {\n  simplifyClaims,\n  simplifyPropertyClaims,\n  simplifyClaim,\n  simplifyQualifiers,\n  simplifyPropertyQualifiers,\n  simplifyQualifier: simplifyClaim,\n  simplifyReferences\n};","map":{"version":3,"names":["parse","parseClaim","require","uniq","truthyPropertyClaims","nonDeprecatedPropertyClaims","simplifyClaims","claims","options","propertyPrefix","parseOptions","simpleClaims","id","propClaims","simplifyPropertyClaims","length","keepNonTruthy","keepNonDeprecated","areSubSnaks","map","claim","simplifyClaim","filter","defined","obj","undefined","keepQualifiers","keepReferences","keepIds","keepHashes","keepTypes","keepSnaktypes","keepRanks","parseKeepOptions","mainsnak","rank","value","datatype","datavalue","snaktype","isQualifierSnak","isReferenceSnak","hash","somevalueValue","novalueValue","Error","valueObj","type","subSnaksOptions","getSubSnakOptions","qualifiers","simplifyQualifiers","references","simplifyReferences","entityPrefix","simplifyPropertyQualifiers","propertyQualifiers","refRecord","simplifyReferenceRecord","snaks","Object","assign","keepOptions","keepAll","forEach","optionName","module","exports","simplifyQualifier"],"sources":["/Users/aarongmduran/Desktop/tornados/tornados/node_modules/wikibase-sdk/lib/helpers/simplify_claims.js"],"sourcesContent":["const { parse: parseClaim } = require('./parse_claim')\nconst { uniq } = require('../utils/utils')\nconst { truthyPropertyClaims, nonDeprecatedPropertyClaims } = require('./rank')\n\n// Expects an entity 'claims' object\n// Ex: entity.claims\nconst simplifyClaims = (claims, ...options) => {\n  const { propertyPrefix } = parseOptions(options)\n  const simpleClaims = {}\n  for (let id in claims) {\n    const propClaims = claims[id]\n    if (propertyPrefix) {\n      id = propertyPrefix + ':' + id\n    }\n    simpleClaims[id] = simplifyPropertyClaims(propClaims, ...options)\n  }\n  return simpleClaims\n}\n\n// Expects the 'claims' array of a particular property\n// Ex: entity.claims.P369\nconst simplifyPropertyClaims = (propClaims, ...options) => {\n  // Avoid to throw on empty inputs to allow to simplify claims array\n  // without having to know if the entity as claims for this property\n  // Ex: simplifyPropertyClaims(entity.claims.P124211616)\n  if (propClaims == null || propClaims.length === 0) return []\n\n  const { keepNonTruthy, keepNonDeprecated, areSubSnaks } = parseOptions(options)\n\n  if (keepNonDeprecated) {\n    propClaims = nonDeprecatedPropertyClaims(propClaims)\n  } else if (!(keepNonTruthy || areSubSnaks)) {\n    propClaims = truthyPropertyClaims(propClaims)\n  }\n\n  propClaims = propClaims\n    .map(claim => simplifyClaim(claim, ...options))\n    // Filter-out novalue and somevalue claims,\n    // unless a novalueValue or a somevalueValue is passed in options\n    .filter(defined)\n\n  // Deduplicate values unless we return a rich value object\n  if (propClaims[0] && typeof propClaims[0] !== 'object') {\n    return uniq(propClaims)\n  } else {\n    return propClaims\n  }\n}\n\n// Considers null as defined\nconst defined = obj => obj !== undefined\n\n// Expects a single claim object\n// Ex: entity.claims.P369[0]\nconst simplifyClaim = (claim, ...options) => {\n  options = parseOptions(options)\n  const { keepQualifiers, keepReferences, keepIds, keepHashes, keepTypes, keepSnaktypes, keepRanks } = parseKeepOptions(options)\n\n  // tries to replace wikidata deep claim object by a simple value\n  // e.g. a string, an entity Qid or an epoch time number\n  const { mainsnak, rank } = claim\n\n  let value, datatype, datavalue, snaktype, isQualifierSnak, isReferenceSnak\n  if (mainsnak) {\n    datatype = mainsnak.datatype\n    datavalue = mainsnak.datavalue\n    snaktype = mainsnak.snaktype\n  } else {\n    // Qualifiers have no mainsnak, and define datatype, datavalue on claim\n    datavalue = claim.datavalue\n    datatype = claim.datatype\n    snaktype = claim.snaktype\n    // Duck typing the sub-snak type\n    if (claim.hash) isQualifierSnak = true\n    else isReferenceSnak = true\n  }\n\n  if (datavalue) {\n    value = parseClaim(datatype, datavalue, options, claim.id)\n  } else {\n    if (snaktype === 'somevalue') value = options.somevalueValue\n    else if (snaktype === 'novalue') value = options.novalueValue\n    else throw new Error('no datavalue or special snaktype found')\n  }\n\n  // Qualifiers should not attempt to keep sub-qualifiers or references\n  if (isQualifierSnak) {\n    if (!(keepHashes || keepTypes || keepSnaktypes)) return value\n\n    const valueObj = { value }\n\n    if (keepHashes) valueObj.hash = claim.hash\n    if (keepTypes) valueObj.type = datatype\n    if (keepSnaktypes) valueObj.snaktype = snaktype\n\n    return valueObj\n  }\n  if (isReferenceSnak) {\n    if (!keepTypes) return value\n\n    return { type: datatype, value }\n  }\n  // No need to test keepHashes as it has no effect if neither\n  // keepQualifiers or keepReferences is true\n  if (!(keepQualifiers || keepReferences || keepIds || keepTypes || keepSnaktypes || keepRanks)) {\n    return value\n  }\n\n  // When keeping qualifiers or references, the value becomes an object\n  // instead of a direct value\n  const valueObj = { value }\n\n  if (keepTypes) valueObj.type = datatype\n\n  if (keepSnaktypes) valueObj.snaktype = snaktype\n\n  if (keepRanks) valueObj.rank = rank\n\n  const subSnaksOptions = getSubSnakOptions(options)\n  subSnaksOptions.keepHashes = keepHashes\n\n  if (keepQualifiers) {\n    valueObj.qualifiers = simplifyQualifiers(claim.qualifiers, subSnaksOptions)\n  }\n\n  if (keepReferences) {\n    claim.references = claim.references || []\n    valueObj.references = simplifyReferences(claim.references, subSnaksOptions)\n  }\n\n  if (keepIds) valueObj.id = claim.id\n\n  return valueObj\n}\n\nconst parseOptions = options => {\n  if (options == null) return {}\n\n  if (options[0] && typeof options[0] === 'object') return options[0]\n\n  // Legacy interface\n  const [ entityPrefix, propertyPrefix, keepQualifiers ] = options\n  return { entityPrefix, propertyPrefix, keepQualifiers }\n}\n\nconst simplifyQualifiers = (qualifiers, options) => {\n  return simplifyClaims(qualifiers, getSubSnakOptions(options))\n}\n\nconst simplifyPropertyQualifiers = (propertyQualifiers, options) => {\n  return simplifyPropertyClaims(propertyQualifiers, getSubSnakOptions(options))\n}\n\nconst simplifyReferences = (references, options) => {\n  return references.map(refRecord => {\n    return simplifyReferenceRecord(refRecord, options)\n  })\n}\n\nconst simplifyReferenceRecord = (refRecord, options) => {\n  const subSnaksOptions = getSubSnakOptions(options)\n  const snaks = simplifyClaims(refRecord.snaks, subSnaksOptions)\n  if (subSnaksOptions.keepHashes) return { snaks, hash: refRecord.hash }\n  else return snaks\n}\n\nconst getSubSnakOptions = (options = {}) => {\n  if (options.areSubSnaks) return options\n  // Using a new object so that the original options object isn't modified\n  else return Object.assign({}, options, { areSubSnaks: true })\n}\n\nconst keepOptions = [ 'keepQualifiers', 'keepReferences', 'keepIds', 'keepHashes', 'keepTypes', 'keepSnaktypes', 'keepRanks', 'keepRichValues' ]\n\nconst parseKeepOptions = options => {\n  if (options.keepAll) {\n    keepOptions.forEach(optionName => {\n      if (options[optionName] == null) options[optionName] = true\n    })\n  }\n  return options\n}\n\nmodule.exports = {\n  simplifyClaims,\n  simplifyPropertyClaims,\n  simplifyClaim,\n  simplifyQualifiers,\n  simplifyPropertyQualifiers,\n  simplifyQualifier: simplifyClaim,\n  simplifyReferences,\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}